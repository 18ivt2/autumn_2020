# -*- coding: utf-8 -*-
"""Machine_learning_insurance

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MuToHDVh2dWckWrc6eGufI1JS2OkyF2m

# Корнилов А.И.
#  18-АС
#  6 Вариант

**Устанавливаем keras tuner.**
"""

!pip install -U keras-tuner

"""**Импортируем модули.**"""

from tensorflow.python.keras.models import Sequential
from tensorflow.python.keras.layers import Dense, Dropout
from sklearn.preprocessing import LabelEncoder
from tensorflow.keras.callbacks import Callback
from kerastuner.tuners import Hyperband
import IPython
import numpy as np
from google.colab import files
import pandas as pd
import matplotlib.pyplot as plt

"""**Загружаем данные**"""

from google.colab import drive
drive.mount('/content/drive')

train = pd.read_csv("/content/drive/My Drive/train.csv")

"""**Просмотр данных**"""

train.head()

"""**Стандартизация данных**"""

labelencoder = LabelEncoder()
cat = pd.DataFrame()
for i in range(1,117):
  cat[f'cat{i}'] = labelencoder.fit_transform(train[f'cat{i}'])
  cat_norm = (cat - cat.mean()) / (cat.max() - cat.min())
data_cont = train.get([f'cont{i}' for i in range(1, 15)])
data_loss = train.get('loss')

cat_norm.head()

"""**Соединяем данные обратно**"""

data = pd.concat([cat_norm, data_cont, data_loss], axis=1)

data.head()

"""**Разделение данных на test и train**"""

split = 0.7
random_seed = 200

train.drop(['id'], axis=1, inplace=True)
y_data = data_loss
x_data = data.drop(['loss'], axis=1)

x_train = x_data.sample(frac=split, random_state=random_seed)
x_test = x_data.drop(x_train.index)

y_train = y_data.sample(frac=split, random_state=random_seed)
y_test = y_data.drop(y_train.index)

x_train.head()

"""**Описание модели**"""

def build_model(hp):
  activation_choice = hp.Choice('activation', values=['relu', 'sigmoid', 'tanh', 'elu', 'selu'])
  hidden_layers_choice = hp.Choice('hidden_layers', values=[0, 1, 2])

  model = Sequential()
  model.add(
      Dense(
          units=hp.Int(
              'input_units',
              min_value=128, 
              max_value=256, 
              step=16,
          ), 
          input_dim=x_train.shape[1], 
          activation=activation_choice,
      ),
  )
  model.add(Dropout(0.3))
  for i in range(hidden_layers_choice):
    model.add(
        Dense(
            units=hp.Int(
                f'layer_{i + 1}_units',
                min_value=64 // (i + 1),
                max_value=128 // (i + 1),
                step=8 // (i + 1),
            ),
            activation=activation_choice
        )
    )
  model.add(Dense(1))

  model.compile(
      optimizer='adam', 
      loss='mae',
      metrics=['mae'], 
  )

  return model

"""**Создание тюнера**"""

tuner = Hyperband(
    build_model,
    objective='mae',
    factor = 3, 
    hyperband_iterations = 2,
    max_epochs=10,
    directory='models',
    project_name='lab1',
)

tuner.search_space_summary()

"""**Очистка результатов в конце каждого шага обучения и поиск оптимальных гиперпараметров**"""

class ClearTrainingOutput(Callback):
  def on_train_end(*args, **kwargs):
    IPython.display.clear_output(wait = True)

tuner.search(
    x_train,
    y_train,
    validation_split=0.2,
    verbose=2,
    callbacks = [ClearTrainingOutput()],
)

"""**Создание модели**"""

best_hps = tuner.get_best_hyperparameters()[0]
model = tuner.hypermodel.build(best_hps)
model.summary()

"""**Обучаем модель**"""

history = model.fit(x_train, y_train, epochs=25, batch_size=30, validation_split=0.2, verbose=2)

"""**Сохраняем модель**"""

model.save(f'/content/drive/My Drive/lab1.h5')

"""**Строим график потерь**"""

def graphs(history):
  history = history.history
  loss = history["loss"]
  val_loss = history["val_loss"]
  epochs = range(1, len(history['loss']) + 1)
  plt.plot(epochs, loss, 'r', label='Training loss')
  plt.plot(epochs, val_loss, 'b', label='Validation loss')
  plt.title('Training and validation loss')
  plt.xlabel('Epochs')
  plt.ylabel('Loss')
  plt.legend()
  plt.show()
  plt.clf()

graphs(history)

mae = model.evaluate(x_test, y_test, verbose=0)[1]
print(f'Средняя абсолютная ошибка = {mae}')

"""**Выполняем предсказание для тестовой выборки**"""

pred = model.predict(x_test)

"""**Печатаем примеры результатов**"""

y_test_normal=y_test.reset_index(drop=True)

for i in range(0,4):
  print("Предсказанная выплата:", pred[i])
  print("Реальная выплата:", y_test_normal[i])
  print("")

x = range(1, len(y_test)+1)
plt.figure(figsize=(20,5))
plt.plot(x, y_test, 'b', label='plot')
plt.plot(x, pred, 'r', label='plot')

plt.legend()
plt.show()
plt.clf()

pred_corr=pred.flatten()
np.corrcoef(pred_corr, y_test.values)